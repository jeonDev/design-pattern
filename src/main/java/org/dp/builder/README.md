# Builder Pattern

- 빌더 패턴은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성 패턴이다.
- 생성자에 들어갈 매개 변수를 메서드로 하나하나 받아들이고 마지막에 통합 빌드해서 객체를 생성하는 방식

## 생성 배경
### 점층적 생성자 패턴
- 점층적 생성자 패턴(Telescoping Constructor Pattern)은 필수 매개변수와 함께 선택 매개변수를 0, 1, 2..개 받는 형태로 우리가 다양한 매개변수를 입력받아 인스턴스를 생성하고 싶을 때 사용하던 생성자를 오버로딩 하는 방식이다.
- 이러한 방식은 클래스 인스턴스 필드들이 많으면 많을수록 생성자에 들어갈 인자의 수가 늘어나 몇번째 인자가 어떤 필드였는지 헷갈릴 경우가 생김.
- 또한, 매개변수 특성상 순서를 따라야 하기 때문에 억지로 임의의 값을 전달해야 한다.
  - 생성자로만으로는 필드를 선택적으로 생략할 수 있는 방법이 없기 때문이다.
- 무엇보다 타입이 다양할 수록 생성자 메서드 수가 기하급수적으로 늘어나 가독성이나 유지보수 측면에서 좋지않다.

### 자바 빈 패턴
- 이러한 단점을 보완하기 위해 Setter 메소드를 사용한 자바 빈(Bean) 패턴이 고안되었다.
- 매개변수가 없는 생성자로 객체 생성 후 Setter 메소드를 이용해 클래스 필드의 초기값을 설정하는 방식.
- 가독성 문제점이 사라지고, 선택적인 파라미터에 대해 해당되는 Setter 메서드를 호출함으로써 유연적으로 객체 생성이 가능해졌다.
- 하지만 이러한 방식은 객체 생성 시점에 모든 값들을 주입하지 않아 일관성(consistency) 문제와 불변성(immutable) 문제가 나타나게 된다.

#### 일관성 문제
- 필수 매개변수란 객체가 초기화될 때 반드시 설정되어야 하는 값이다.
- 하지만 개발자가 깜빡하고 set 메서드를 호출하지 않았다면 이 객체는 일관성이 무너진 상태가 된다.
- 즉, 객체가 유효하지 않은 것이다.
- 이는 객체를 생성하는 부분과 값을 설정하는 부분이 물리적으로 떨어져 있어서 발생하는 문제점이다.
- 물롱 이는 어느정도 생성자와 결합하여 극복은 가능.

#### 불변성 문제
- 자바 빈즈 패턴의 Setter 메서드는 객체를 처음 생성할 때 필드값을 설정하기 위해 존재하는 메서드이다.
- 하지만 객체를 생성했음에도 여전히 외부적으로 Setter 메소드를 노출하고 있으므로, 협업 과정에서 언제 어디서 누군가 Setter 메서드를 호출해 함부로 객체를 조작할 수 있게 된다.
- 이것을 불변함을 보장할 수 없다고 얘기한다.


## 빌더 패턴
- 빌더 패턴은 이러한 문제들을 해결하기 위해 별도의 Builder 클래스를 만들어 메소드를 통해 step-by-step 으로 값을 입력받은 후에 최종적으로 build() 메소드로 하나의 인스턴스를 생성하여 리턴하는 패턴이다.
- 메서드를 체이닝(Chaining) 형태로 호출함으로써 자연스럽게 인스턴스를 구성하고 마지막에 build() 메서드를 통해 최종적으로 객체를 생성하도록 되어 있음.
- 더 이상 생성자 오버로딩을 열거하지 않아도 되고, 데이터의 순서에 상관없이 객체를 만들어내 생성자 인자 순서를 파악할 필요도 없고, 잘못된 값을 넣는 실수도 하지 않게 된다.
- 점층적 생성자 패턴과 자바빈즈 패턴의 두 가지 장점만을 취하였다고 볼 수 있다.

### 빌더 패턴 네이밍 형식
- 멤버이름()
  - 추천
- set멤버이름()
  - Setter 와 헷갈릴 소지 있음
- with멤버이름()
  - 빌더 지연 생성 방식에서 미리 빌더를 설정할 때 쓰이기도 함.

### 빌더 패턴 장단점
#### 장점
1. 객체 생성 과정을 일관된 프로세스로 표현
2. 디폴트 매개변수 생략을 간접적으로 지원
3. 필수 멤버와 선택적 멤버를 분리 가능
4. 객체 생성 단계를 지연할 수 있음
5. 초기화 검증을 멤버별로 분리
6. 멤버에 대한 변경 가능성 최소화를 추구
   - 클래스 멤버 초기화를 Setter를 통해 구성하는 것은 매우 좋지 않은 방법이다.
   - 일반적으로 프로그램을 개발하는데 있어 다른 사람과 협업할 때 가장 중요시되는 점 중 하나가 불변객체이다.
     - 읽기 메소드만을 제공하며 쓰기는 제공하지 않는다.
     - 현업에서 불변 객체를 이용해 개발해야 하는 이유
       - 불변 객체는 Thread-Safe 하여 동기화를 고려하지 않아도 된다.
       - 만일 가변 객체를 통해 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있어 또 다른 에러를 유발할 수 있는 위험성이 있기 때문이다.
       - 불변 객체로 구성하면 다른 사람이 개발한 함수를 위험없이 이용을 보장할 수 있어 협업에도 유지보수에도 유용하다.
  - 따라서 클래스들은 가변적이어야 하는 매우 타당한 이유가 있지 않는 한 반드시 불변으로 만들어야 한다.
  - 만약 클래스를 불변으로 만드는 것이 불가능하다면 가능한 변경 가능성을 최소화 해야 한다.
    - final 키워드를 붙일 수 없는 상황 -> Setter 메서드 자체를 구현하지 않음으로서 불변 객체를 간접적으로 구성이 가능.
      - 그럼 결국 돌고 돌아 생성자를 이용하라 인데 역시나 지나친 생성자 오버로딩 문제 발생 -> 빌더 패턴!

#### 단점
1. 코드 복잡성 증가
2. 생성자보다는 성능은 떨어진다.
3. 지나친 빌더 남용은 금지
   - 클래스의 필드의 개수가 4개보다 적고, 필드의 변경 가능성이 없는 경우라면 차라리 생성자나 정적 팩토리 메소드를 이용하는 것이 더 좋을 수 있다.
   - 빌더 패턴의 코드가 다소 장황하기 때문.


### 빌더 디자인 패턴 종류
- 이펙티브 자바의 빌더 패턴
  - 생성 시 지정해야 할 인자가 많을 때 사용. 객체의 일관성 불변성이 목적
- GoF의 빌더 패턴
  - 객체의 생성 단계 순서를 결정해두고 각 단계를 다양하게 구현하고 싶을 때 사용.

### 심플 빌더 패턴(Effective Java)
- 심플 빌더 패턴은 생성자가 많을 경우 또는 변경 불가능한 불변 객체가 필요한 경우 코드의 가독성과 일관성, 불변성을 유지하는 것에 중점을 둔다.
- 심플 빌더 패턴은 위에서 우리가 배운 빌더 패턴과 차이가 거의 없다.
- 다만 빌더 클래스가 구현할 클래스의 정적 내부 클래스로 구현된다는 점이 다르다.
  - public static class Builder{}
- 빌더 클래스가 static inner class로 구현되는 이유
  - 하나의 빌더 클래스는 하나의 대상 객체 생성만을 위해 사용된다.
  - 대상 객체는 오로지 빌더 객체에 의해 초기화 된다. 즉, 생성자를 외부에 노출시키면 안되기 때문에 생성자를 private로 하고, 내부 빌더 클래스에서 private 생성자를 호출함으로써 오로지 빌더 객체에 의해 초기화되도록 설계
  - 정적 내부 클래스는 외부 클래스의 인스턴스 없이도 생성할 수 있는데, 만일 일반 내부 클래스로 구성한다면 내부 클래스를 생성하기도 전에 외부 클래스를 인스턴스화 해야 한다. 빌더가 최종적으로 생성할 클래스의 인스턴스를 먼저 생성해야 한다면 모순이 생기기 때문에 static
  - 메모리 누수 문제 때문에 static으로 내부 클래스를 정의해주어야 한다.
    - 참고 : https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9E%90%EB%B0%94%EC%9D%98-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-static-%EC%9C%BC%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%98%EC%9E%90

### 디렉터 빌더 패턴 (GoF)
- 객체의 생성 알고리즘과 조립 방법을 분리하여 빌드 공정을 구축하는 것이 목적.
- 구조
  - Builder
    - 빌더 추상 클래스
  - ConcreteBuilder
    - Builder의 구현체
  - Director
    - Builder에서 제공하는 메소드들을 사용해 정해진 순서대로 생성하는 프로세스를 정의
  - Product
    - Director가 Builder로 만들어낸 결과물
- 이러한 구조는 클라이언트가 직접 빌더의 모든 API를 사용하는게 아닌, Director을 통해서 간단하게 인스턴스를 얻어올 수 있고, 코드를 재사용할 수 있도록 한다.

...

## Lombok의 @Builder
- @Builder
- @AllArgsConstructor(access = AccessLevel.PRIVATE)
- @ToString