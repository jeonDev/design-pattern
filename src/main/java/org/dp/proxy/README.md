- 프록시 패턴은 대상 원본 객체를 대리하여 대신 처리하게 함으로써 로직의 흐름을 제어하는 행동 패턴
- 이렇게 번거롭게 중계 대리자를 통해 이용하는 방식을 취하는 이유는, 대상 클래스가 민감한 정보를 가지고 있거나, 인스턴스화 하기에 무겁거나 추가 기능을 가미하고 싶은데, 원본 객체를 수정할 수 없는 상황일 때를 극복하기 위함.

# 예시

|   | 효과                                                                    |
|---|-----------------------------------------------------------------------|
| 보안| 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사 결과가 긍정적인 경우에만 요청을 대상으로 전달한다. |
| 캐싱| 프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 한다.          |
| 데이터 유효성 검사 | 프록시가 입력을 대상으로 전달하기 전에 유효성을 검사한다.                                      |
| 지연 초기화| 대상의 생성 비용이 비싸다면 프록시는 그것을 필요로 할 때까지 연기할 수 있다.                          |
|로깅| 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록한다.                                |
|원격 객체| 프록시는 원격 위치에 있는 객체를 가져와서 로컬처럼 보이게 할 수 있다.                              |

# 프록시 패턴 구조

- 프록시는 다른 객체에 대한 접근을 제어하는 개체이다.
- 여기서 다른 객체를 대상(Subject)라고 부른다.
- 프록시와 대상은 동일한 인터페이스를 가지고 있으며 이를 통해 다른 인터페이스와 완전히 호환되도록 바꿀 수 있다.

- Subject : Proxy와 RealSubject를 하나로 묶는 인터페이스 (다형성)
  - 대상 객체와 프록시 역할을 동일하게 하는 추상 메소드 operation() 을 정의한다.
  - 인터페이스가 있기 때문에 클라이언트는 Proxy 역할과 RealSubject 역할의 차이를 의식할 필요가 없다.
- RealSubject : 원본 대상 객체
- Proxy : 대상 객체(RealSubject)를 중계할 대리자 역할
  - 프록시는 대상 객체를 합성(composition)한다.
  - 프록시는 대상 객체와 같은 이름의 메서드를 호출하며, 별도의 로직을 수행할 수 있다. (인터페이스 구현 메소드)
  - 프록시는 흐름제어만 할 뿐 결과값을 조작하거나 변경시키면 안 된다.
- Client : Subject 인터페이스를 이용하여 프록시 객체를 생성해 이용.
  - 클라이언트는 프록시를 중간에 두고 프록시를 통해서 RealSubject와 데이터를 주고 받는다.

# 프록시 패턴 종류
- 기본형 프록시 (Normal Proxy)
- 가상 프록시 (Virtual Proxy)
- 보호 프록시 (Protection Proxy)
- 로깅 프록시 (Logging Proxy)
- 원격 프록시 (Remote Proxy)
- 캐싱 프록시 (Caching Proxy)

# 프록시 패턴 특징
- 패턴 사용 시기
  - 기능을 추가하고 싶은데 기존의 특정 객체를 수정할 수 없는 상황일 때.
  - 초기화 지연, 접근 제어, 로깅, 캐싱 등 기존 객체 동작에 수정 없이 가미하고 싶을 때.

- 패턴 장점
  - 개방 폐쇄 원칙 (OCP) 준수
    - 기존 대상 객체의 코드를 변경하지 않고 새로운 기능을 추가할 수 있다.
  - 단일 책임 원칙 (SRP) 준수
    - 대상 객체는 자신의 기능에만 집중하고, 그 외의 부가 기능을 제공하는 역할을 프록시 객체에 위임하여 다중 책임을 회피할 수 있다.
  - 클라이언트는 객체를 신경쓰지 않고, 서비스 객체를 제어하거나 생명 주기를 관리할 수 있다.

- 패턴 단점
  - 많은 프록시 클래스를 도입해야 하므로 코드의 복잡도가 증가한다.
    - 예를들어 여러 클래스에 로깅 기능을 가미 시키고 싶다면, 동일한 코드를 적용함에도 각각의 클래스에 해당되는 프록시 클래스를 만들어서 적용해야 되기 때문에 코드량이 많아지고 중복이 발생 된다.
    - 자바에서는 리플렉션에서 제공하는 동적 프록시 (Dynamic Proxy) 기법을 이용해서 해결할 수 있다.
  - 프록시 클래스 자체에 들어가는 자원이 많다면 서비스로부터의 응답이 늦어질 수 있다.


# Java
1. java.lang.reflect.Proxy
2. java.rmi.* (원격 프록시 모듈)
3. javax.ejb.EJB
4. javax.inject.Inject
5. javax.persistence.PersistenceContext

# Dynamic Proxy
- 개발자가 직접 디자인 패턴으로서 프록시 패턴을 구현해도 되지만, 자바 JDK에서는 별도로 프록시 객체 구현 기능을 지원한다.
- 이를 동적 프록시(Dynamic Proxy) 기법이라고 부른다.
- 동적 프록시는 개발자가 일일이 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 java.lang.reflect.Proxy 패키지에서 제공해주는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법으로서 자바의 Refelection API 기법을 응용한 연장선의 개념이다.
- 그래서 별도의 프록스 클래스 정의 없이 런타임으로 프록시 객체를 동적으로 생성해 이용할 수 있다는 장점이 있다.
    - 참고 : https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EB%88%84%EA%B5%AC%EB%82%98-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-Dynamic-Proxy-%EB%8B%A4%EB%A3%A8%EA%B8%B0

# Spring Framework
1. Spring AOP

# JavaScript
1. Proxy / Reflect 객체

출처: https://inpa.tistory.com/entry/GOF-💠-프록시Proxy-패턴-제대로-배워보자 [Inpa Dev 👨‍💻:티스토리]